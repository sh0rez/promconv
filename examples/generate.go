package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	exampleDir := "examples"

	err := filepath.WalkDir(".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, "_test.go") {
			return extractExamplesFromFile(path, exampleDir)
		}
		return nil
	})

	if err != nil {
		fmt.Println("Error walking directory:", err)
	}
}

func extractExamplesFromFile(filePath, outDir string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse file: %w", err)
	}

	for _, decl := range node.Decls {
		funcDecl, ok := decl.(*ast.FuncDecl)
		if !ok || funcDecl.Recv != nil || !strings.HasPrefix(funcDecl.Name.Name, "Example") {
			continue
		}

		// Look for //example: comment before the function
		exampleName := ""
		if funcDecl.Doc != nil {
			for _, comment := range funcDecl.Doc.List {
				text := strings.TrimSpace(comment.Text)
				if strings.HasPrefix(text, "//example:") {
					exampleName = strings.TrimSpace(strings.TrimPrefix(text, "//example:"))
					break
				}
			}
		}

		// If no //example: comment found, print an error
		if exampleName == "" {
			fmt.Printf("Error: Example function %s in %s is missing //example: comment\n", funcDecl.Name.Name, filePath)
			continue
		}

		// Calculate the import path for the original package
		originalPackageName := node.Name.Name
		packageImportPath := calculateImportPath(filePath, originalPackageName)

		// Use "sem" prefix for otel packages to avoid naming collisions
		aliasedPackageName := "sem" + originalPackageName

		// Create output directory and file
		os.MkdirAll(filepath.Join(outDir, exampleName), os.ModePerm)
		outPath := filepath.Join(outDir, exampleName, "main.go")

		outFile, err := os.Create(outPath)
		if err != nil {
			return fmt.Errorf("creating output file: %w", err)
		}
		defer outFile.Close()

		// Write package declaration
		fmt.Fprintln(outFile, "// Code generated by examples/generate.go; DO NOT EDIT.")
		fmt.Fprintln(outFile, "")
		fmt.Fprintln(outFile, "package main")

		// Collect necessary imports
		imports := collectImports(node)

		// Add the original package import if it's not already imported
		if packageImportPath != "" {
			imports = append(imports, fmt.Sprintf("%s \"%s\"", aliasedPackageName, packageImportPath))
		}

		if len(imports) > 0 {
			fmt.Fprintln(outFile, "\nimport (")
			for _, imp := range imports {
				fmt.Fprintf(outFile, "\t%s\n", imp)
			}
			fmt.Fprintln(outFile, ")")
		}

		// Convert Example function to main
		fmt.Fprintln(outFile, "\nfunc main() {")
		for _, stmt := range funcDecl.Body.List {
			// Add package prefix to function calls that belong to the original package using AST
			addPackagePrefixToAST(stmt, aliasedPackageName, getImportedPackageNames(node))

			// Write the statement directly to the file with indentation
			fmt.Fprint(outFile, "\t")
			printer.Fprint(outFile, fset, stmt)
			fmt.Fprintln(outFile)
		}
		fmt.Fprintln(outFile, "}")

		fmt.Println("Extracted:", outPath)
	}

	return nil
}

// calculateImportPath determines the import path for the original package
func calculateImportPath(filePath, packageName string) string {
	// Remove the filename and get the directory
	dir := filepath.Dir(filePath)

	// Convert file path to import path (assuming module root is current directory)
	// For example: "otel/http/example_test.go" -> "shorez.de/promconv/otel/http"
	if dir == "." {
		return ""
	}

	// Replace backslashes with forward slashes for import paths
	importPath := strings.ReplaceAll(dir, "\\", "/")
	return "shorez.de/promconv/" + importPath
}

func collectImports(file *ast.File) []string {
	var imports []string
	for _, imp := range file.Imports {
		if imp.Name != nil {
			imports = append(imports, fmt.Sprintf("%s %s", imp.Name.Name, imp.Path.Value))
		} else {
			imports = append(imports, imp.Path.Value)
		}
	}
	return imports
}

func addPackagePrefixToAST(stmt ast.Stmt, packageName string, importedPackageNames []string) {
	ast.Inspect(stmt, func(node ast.Node) bool {
		switch n := node.(type) {
		case *ast.CallExpr:
			// Check if this is an unqualified function call (just an identifier)
			if ident, ok := n.Fun.(*ast.Ident); ok {
				// If it's an exported function (starts with uppercase) and not an imported package name
				if isExportedFunction(ident.Name) && !isImportedPackage(ident.Name, importedPackageNames) {
					// Convert to qualified call: funcName -> packageName.funcName
					n.Fun = &ast.SelectorExpr{
						X:   &ast.Ident{Name: packageName},
						Sel: ident,
					}
				}
			}
		}
		return true
	})
}

func isExportedFunction(name string) bool {
	return len(name) > 0 && name[0] >= 'A' && name[0] <= 'Z'
}

func isImportedPackage(name string, importedPackageNames []string) bool {
	for _, pkgName := range importedPackageNames {
		if name == pkgName {
			return true
		}
	}
	return false
}

func getImportedPackageNames(file *ast.File) []string {
	var packageNames []string
	for _, imp := range file.Imports {
		if imp.Name != nil {
			// Aliased import
			packageNames = append(packageNames, imp.Name.Name)
		} else {
			// Regular import - extract package name from path
			path := strings.Trim(imp.Path.Value, `"`)
			parts := strings.Split(path, "/")
			if len(parts) > 0 {
				packageNames = append(packageNames, parts[len(parts)-1])
			}
		}
	}
	return packageNames
}
